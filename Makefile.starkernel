# Makefile.starkernel - Build system for StarKernel
# Multi-architecture UEFI kernel build system with loader+kernel split

# Architecture detection
UNAME_M := $(shell uname -m)
ifeq ($(UNAME_M),x86_64)
    ARCH ?= amd64
else ifeq ($(UNAME_M),aarch64)
    ARCH ?= aarch64
else ifeq ($(UNAME_M),arm64)
    ARCH ?= aarch64
else ifeq ($(UNAME_M),riscv64)
    ARCH ?= riscv64
else
    ARCH ?= amd64
endif

# Target type
TARGET ?= kernel

# Deterministic parity mode (0 = normal, 1 = parity harness)
PARITY_MODE ?= 0

# Build output directory
BUILD_DIR := build/$(ARCH)/$(TARGET)
OBJ_DIR := $(BUILD_DIR)/obj
LOADER_OBJ_DIR := $(OBJ_DIR)/loader
KERNEL_OBJ_DIR := $(OBJ_DIR)/kernel
STARFORTH_CONFIG_HEADER := include/starforth_config.h

# Output files
LOADER_EFI := $(BUILD_DIR)/starkernel_loader.efi
KERNEL_ELF := $(BUILD_DIR)/starkernel_kernel.elf

# Source directories
KERNEL_SRC := src/starkernel
KERNEL_INC := include/starkernel

# Toolchain configuration per architecture
ifeq ($(ARCH),amd64)
    # Try x86_64-elf-gcc first, fall back to native gcc
    ifneq ($(shell which x86_64-elf-gcc 2>/dev/null),)
        CC := x86_64-elf-gcc
        LD := x86_64-elf-ld
        OBJCOPY := x86_64-elf-objcopy
    else
        CC := gcc
        LD := ld
        OBJCOPY := objcopy
    endif
    ARCH_CFLAGS := -m64 -march=x86-64 -mno-red-zone -DARCH_AMD64
    LOADER_LINKER_SCRIPT := linker/starkernel-loader-amd64.ld
    KERNEL_LINKER_SCRIPT := linker/starkernel-kernel-amd64.ld
    EFI_TARGET := efi-app-x86_64
else ifeq ($(ARCH),aarch64)
    # Try aarch64-linux-gnu-gcc first, fall back to aarch64-none-elf-gcc
    ifneq ($(shell which aarch64-linux-gnu-gcc 2>/dev/null),)
        CC := aarch64-linux-gnu-gcc
        LD := aarch64-linux-gnu-ld
        OBJCOPY := aarch64-linux-gnu-objcopy
    else ifneq ($(shell which aarch64-none-elf-gcc 2>/dev/null),)
        CC := aarch64-none-elf-gcc
        LD := aarch64-none-elf-ld
        OBJCOPY := aarch64-none-elf-objcopy
    else
        $(error No ARM64 toolchain found. Install aarch64-linux-gnu-gcc or aarch64-none-elf-gcc)
    endif
    ARCH_CFLAGS := -march=armv8-a -mcpu=cortex-a72
    LOADER_LINKER_SCRIPT := linker/starkernel-loader-aarch64.ld
    KERNEL_LINKER_SCRIPT := linker/starkernel-kernel-aarch64.ld
    EFI_TARGET := efi-app-aarch64
else ifeq ($(ARCH),riscv64)
    # Try riscv64-unknown-elf-gcc first, fall back to riscv64-linux-gnu-gcc
    ifneq ($(shell which riscv64-unknown-elf-gcc 2>/dev/null),)
        CC := riscv64-unknown-elf-gcc
        LD := riscv64-unknown-elf-ld
        OBJCOPY := riscv64-unknown-elf-objcopy
    else ifneq ($(shell which riscv64-linux-gnu-gcc 2>/dev/null),)
        CC := riscv64-linux-gnu-gcc
        LD := riscv64-linux-gnu-ld
        OBJCOPY := riscv64-linux-gnu-objcopy
    else
        $(error No RISC-V toolchain found. Install riscv64-unknown-elf-gcc or riscv64-linux-gnu-gcc)
    endif
    ARCH_CFLAGS := -march=rv64gc -mabi=lp64d
    LOADER_LINKER_SCRIPT := linker/starkernel-loader-riscv64.ld
    KERNEL_LINKER_SCRIPT := linker/starkernel-kernel-riscv64.ld
    EFI_TARGET := efi-app-riscv64
else
    $(error Unsupported architecture: $(ARCH))
endif

# Common compiler flags
# Use -fPIC with -fvisibility=hidden: This makes all symbols local by default,
# preventing GOT references for internal function pointers. Without hidden
# visibility, -fPIC generates GOT loads for external symbols which read
# function code bytes instead of addresses (PE has no GOT).
COMMON_CFLAGS := -std=c99 -Wall -Werror -Wextra \
                 -ffreestanding -nostdlib -fno-builtin \
                 -fPIC -fvisibility=hidden -fno-stack-protector -fshort-wchar \
                 $(ARCH_CFLAGS) \
                 -I$(KERNEL_INC) -Iinclude -Isrc -include $(STARFORTH_CONFIG_HEADER) \
                 -DPARITY_MODE=$(PARITY_MODE)
VMCORE_CFLAGS_COMMON := $(filter-out -I$(KERNEL_INC),$(COMMON_CFLAGS)) -Iinclude -I. -Wno-error=unused-parameter -Wno-error=shift-negative-value -Wno-error=sign-compare

# Loader-specific flags
LOADER_CFLAGS := $(COMMON_CFLAGS) -I$(KERNEL_SRC)/vm

# Kernel-specific flags (with __STARKERNEL__ fence)
KERNEL_CFLAGS := $(COMMON_CFLAGS) -D__STARKERNEL__ -I$(KERNEL_SRC)/vm

# VM integration (M7) - enabled by default
STARFORTH_ENABLE_VM ?= 1
ifeq ($(STARFORTH_ENABLE_VM),1)
KERNEL_CFLAGS += -DSTARFORTH_ENABLE_VM=1
LOADER_CFLAGS += -DSTARFORTH_ENABLE_VM=1
KERNEL_CFLAGS += -DSTARFORTH_MINIMAL=1
LOADER_CFLAGS += -DSTARFORTH_MINIMAL=1
VM_FEATURE_OVERRIDES :=
VM_FEATURE_FLAG_VARS := STRICT_PTR ENABLE_HOTWORDS_CACHE ENABLE_PIPELINING ROLLING_WINDOW_SIZE \
                        TRANSITION_WINDOW_SIZE ADAPTIVE_SHRINK_RATE ADAPTIVE_MIN_WINDOW_SIZE \
                        ADAPTIVE_CHECK_FREQUENCY ADAPTIVE_GROWTH_THRESHOLD INITIAL_DECAY_SLOPE_Q48 \
                        DECAY_MIN_INTERVAL DECAY_RATE_PER_US_Q16 HEARTBEAT_THREAD_ENABLED \
                        HEARTBEAT_TICK_NS HEARTBEAT_INFERENCE_FREQUENCY HEARTBEAT_CHECK_FREQUENCY \
                        HEARTBEAT_WINDOW_TUNING_FREQUENCY HEARTBEAT_SLOPE_VALIDATION_FREQUENCY \
                        SK_PARITY_DEBUG

define add_kernel_vm_flag_if_set
ifneq ($$(origin $1),undefined)
VM_FEATURE_OVERRIDES += -D$1=$$($1)
endif
endef

$(foreach flag,$(VM_FEATURE_FLAG_VARS),$(eval $(call add_kernel_vm_flag_if_set,$(flag))))
VM_FEATURE_OVERRIDES += -DHEARTBEAT_THREAD_ENABLED=0

KERNEL_CFLAGS += $(VM_FEATURE_OVERRIDES)
LOADER_CFLAGS += $(VM_FEATURE_OVERRIDES)
endif

# Self-test flags (M4 exception tests, M5 timer validation)
ifdef DIV0_SELF_TEST
KERNEL_CFLAGS += -DDIV0_SELF_TEST=$(DIV0_SELF_TEST)
endif
ifdef PF_SELF_TEST_READ
KERNEL_CFLAGS += -DPF_SELF_TEST_READ=$(PF_SELF_TEST_READ)
endif
ifdef PF_SELF_TEST_WRITE
KERNEL_CFLAGS += -DPF_SELF_TEST_WRITE=$(PF_SELF_TEST_WRITE)
endif
ifdef M5_TIMER_VALIDATION
KERNEL_CFLAGS += -DM5_TIMER_VALIDATION=$(M5_TIMER_VALIDATION)
endif

# Linker flags
# PE direct linking with proper base relocations (--enable-reloc-section generates .reloc)
# --image-base 0 allows UEFI to freely relocate; section alignment is 4K
LOADER_LINKER_SCRIPT_PE := linker/starkernel-loader-amd64-pe.ld
LOADER_LDFLAGS_PE := -T $(LOADER_LINKER_SCRIPT_PE) -m i386pep -nostdlib --enable-reloc-section --image-base 0 --subsystem 10 -e efi_main
# ELF linking (used as intermediate or for kernel)
LOADER_LDFLAGS := -T $(LOADER_LINKER_SCRIPT) -nostdlib --build-id=none --emit-relocs -shared -Bsymbolic -znocombreloc -e efi_main
KERNEL_LDFLAGS := -T $(KERNEL_LINKER_SCRIPT) -nostdlib --build-id=none --emit-relocs -e kernel_main

# Monolithic build includes kernel in loader (no separate ELF loading)
MONOLITHIC ?= 1

ifeq ($(MONOLITHIC),1)
# Monolithic: loader + kernel compiled together
LOADER_CFLAGS += -DMONOLITHIC_BUILD -D__STARKERNEL__
# Pass self-test flags to loader (which includes kernel_main.c)
ifdef DIV0_SELF_TEST
LOADER_CFLAGS += -DDIV0_SELF_TEST=$(DIV0_SELF_TEST)
endif
ifdef PF_SELF_TEST_READ
LOADER_CFLAGS += -DPF_SELF_TEST_READ=$(PF_SELF_TEST_READ)
endif
ifdef PF_SELF_TEST_WRITE
LOADER_CFLAGS += -DPF_SELF_TEST_WRITE=$(PF_SELF_TEST_WRITE)
endif
ifdef M5_TIMER_VALIDATION
LOADER_CFLAGS += -DM5_TIMER_VALIDATION=$(M5_TIMER_VALIDATION)
endif

LOADER_SRCS_BASE := $(KERNEL_SRC)/boot/uefi_loader.c \
                    $(KERNEL_SRC)/boot/elf_loader.c \
                    $(KERNEL_SRC)/boot/reloc_stub.c \
                    $(KERNEL_SRC)/kernel_main.c \
                    $(wildcard $(KERNEL_SRC)/hal/*.c) \
                    $(wildcard $(KERNEL_SRC)/memory/*.c) \
                    $(wildcard $(KERNEL_SRC)/math/*.c)

LOADER_ASM := $(KERNEL_SRC)/arch/$(ARCH)/boot.S \
              $(KERNEL_SRC)/arch/$(ARCH)/isr.S

LOADER_ARCH_SRCS := $(KERNEL_SRC)/arch/$(ARCH)/arch.c \
                    $(KERNEL_SRC)/arch/$(ARCH)/interrupts.c \
                    $(KERNEL_SRC)/arch/$(ARCH)/apic.c \
                    $(KERNEL_SRC)/arch/$(ARCH)/timer.c
else
# Split build: loader loads kernel.elf from disk
LOADER_SRCS_BASE := $(KERNEL_SRC)/boot/uefi_loader.c \
                    $(KERNEL_SRC)/boot/elf_loader.c \
                    $(KERNEL_SRC)/boot/reloc_stub.c

LOADER_ASM :=

LOADER_ARCH_SRCS := $(KERNEL_SRC)/arch/$(ARCH)/arch.c
endif

# Kernel source files (everything except loader boot files)
KERNEL_SRCS_BASE := $(KERNEL_SRC)/kernel_main.c \
                    $(wildcard $(KERNEL_SRC)/hal/*.c) \
                    $(wildcard $(KERNEL_SRC)/memory/*.c) \
                    $(wildcard $(KERNEL_SRC)/math/*.c) \
                    $(wildcard $(KERNEL_SRC)/vm_arbiter/*.c) \
                    $(wildcard $(KERNEL_SRC)/arch/$(ARCH)/*.c)

# Note: arch.c is compiled for BOTH loader and kernel (they're separate binaries)

KERNEL_ASM := $(wildcard $(KERNEL_SRC)/arch/$(ARCH)/*.S)

# VM integration sources (gated)
ifeq ($(STARFORTH_ENABLE_VM),1)
# Hosted VM core sources, excluding CLI/REPL/tests/platform/blkio/log/split-files
VM_ALL_SRCS := $(wildcard src/*.c) $(wildcard src/word_source/*.c)
VM_EXCLUDE := src/main.c src/cli.c src/repl.c src/test_runner/% src/platform/% src/blkio_factory.c src/blkio_file.c src/blkio_ram.c src/log.c src/doe_metrics.c \
              src/vm.c src/vm_core.c src/vm_bootstrap.c src/vm_runtime.c src/vm_time.c \
              src/word_source/q48_16_words.c

VM_CORE_SRCS := $(filter-out $(VM_EXCLUDE),$(VM_ALL_SRCS))

LOADER_EXTRA_SRCS := $(KERNEL_SRC)/vm/arena.c \
                     $(KERNEL_SRC)/vm/parity.c \
                     $(KERNEL_SRC)/vm/bootstrap/sk_vm_bootstrap.c \
                     $(KERNEL_SRC)/vm/host/shim.c \
                     $(KERNEL_SRC)/vm/vm_core.c \
                     $(KERNEL_SRC)/vm/vm_bootstrap.c \
                     $(KERNEL_SRC)/vm/vm_runtime.c \
                     $(KERNEL_SRC)/vm/alloc_kernel.c \
                     $(KERNEL_SRC)/vm/q48_stubs.c

KERNEL_EXTRA_SRCS := $(LOADER_EXTRA_SRCS)

LOADER_VM_OBJS := $(patsubst src/%.c,$(LOADER_OBJ_DIR)/vmcore/%.o,$(VM_CORE_SRCS))
KERNEL_VM_OBJS := $(patsubst src/%.c,$(KERNEL_OBJ_DIR)/vmcore/%.o,$(VM_CORE_SRCS))
endif

LOADER_SRCS := $(LOADER_SRCS_BASE) $(LOADER_EXTRA_SRCS)
KERNEL_SRCS := $(KERNEL_SRCS_BASE) $(KERNEL_EXTRA_SRCS)

LOADER_OBJS := $(patsubst $(KERNEL_SRC)/%.c,$(LOADER_OBJ_DIR)/%.o,$(LOADER_SRCS)) \
               $(patsubst $(KERNEL_SRC)/%.c,$(LOADER_OBJ_DIR)/%.o,$(LOADER_ARCH_SRCS)) \
               $(patsubst $(KERNEL_SRC)/%.S,$(LOADER_OBJ_DIR)/%.o,$(LOADER_ASM)) \
               $(LOADER_VM_OBJS)

KERNEL_OBJS := $(patsubst $(KERNEL_SRC)/%.c,$(KERNEL_OBJ_DIR)/%.o,$(KERNEL_SRCS)) \
               $(patsubst $(KERNEL_SRC)/%.S,$(KERNEL_OBJ_DIR)/%.o,$(KERNEL_ASM)) \
               $(KERNEL_VM_OBJS)

# Default target: build both loader and kernel
.PHONY: all
all: $(LOADER_EFI) $(KERNEL_ELF)
	@echo "StarKernel built successfully for $(ARCH)"
	@echo "  Loader: $(LOADER_EFI)"
	@echo "  Kernel: $(KERNEL_ELF)"

# Create build directories
$(BUILD_DIR) $(LOADER_OBJ_DIR) $(KERNEL_OBJ_DIR):
	@mkdir -p $(LOADER_OBJ_DIR)/boot $(LOADER_OBJ_DIR)/arch/$(ARCH) $(LOADER_OBJ_DIR)/vm
	@mkdir -p $(KERNEL_OBJ_DIR)/boot $(KERNEL_OBJ_DIR)/hal $(KERNEL_OBJ_DIR)/memory $(KERNEL_OBJ_DIR)/vm_arbiter $(KERNEL_OBJ_DIR)/arch/$(ARCH) $(KERNEL_OBJ_DIR)/vm

# Compile loader C sources
$(LOADER_OBJ_DIR)/%.o: $(KERNEL_SRC)/%.c | $(LOADER_OBJ_DIR)
	@mkdir -p $(dir $@)
	@echo "CC (loader) $<"
	@$(CC) $(LOADER_CFLAGS) -c $< -o $@

# Compile loader VM core sources (hosted VM code)
$(LOADER_OBJ_DIR)/vmcore/%.o: src/%.c | $(LOADER_OBJ_DIR)
	@mkdir -p $(dir $@)
	@echo "CC (loader) $<"
	@$(CC) $(VMCORE_CFLAGS_COMMON) $(filter-out -I$(KERNEL_INC),$(LOADER_CFLAGS)) -c $< -o $@

# Compile loader assembly sources
$(LOADER_OBJ_DIR)/%.o: $(KERNEL_SRC)/%.S | $(LOADER_OBJ_DIR)
	@mkdir -p $(dir $@)
	@echo "AS (loader) $<"
	@$(CC) $(LOADER_CFLAGS) -c $< -o $@

# Compile kernel C sources
$(KERNEL_OBJ_DIR)/%.o: $(KERNEL_SRC)/%.c | $(KERNEL_OBJ_DIR)
	@mkdir -p $(dir $@)
	@echo "CC (kernel) $<"
	@$(CC) $(KERNEL_CFLAGS) -c $< -o $@

# Compile kernel VM core sources (hosted VM code)
$(KERNEL_OBJ_DIR)/vmcore/%.o: src/%.c | $(KERNEL_OBJ_DIR)
	@mkdir -p $(dir $@)
	@echo "CC (kernel) $<"
	@$(CC) $(VMCORE_CFLAGS_COMMON) $(filter-out -I$(KERNEL_INC),$(KERNEL_CFLAGS)) -Isrc/starkernel/vm -c $< -o $@

# Compile kernel assembly sources
$(KERNEL_OBJ_DIR)/%.o: $(KERNEL_SRC)/%.S | $(KERNEL_OBJ_DIR)
	@mkdir -p $(dir $@)
	@echo "AS (kernel) $<"
	@$(CC) $(KERNEL_CFLAGS) -c $< -o $@

# Link loader directly to PE32+ with proper base relocations
# --enable-reloc-section generates the .reloc entries needed for UEFI to relocate the image
$(LOADER_EFI): $(LOADER_OBJS) | $(BUILD_DIR)
	@echo "LD (loader PE) $@"
	@$(LD) $(LOADER_LDFLAGS_PE) $(LOADER_OBJS) -o $@
	@echo "Loader built: $@"

# Keep ELF target for debugging (optional)
$(BUILD_DIR)/starkernel_loader.elf: $(LOADER_OBJS) $(LOADER_LINKER_SCRIPT) | $(BUILD_DIR)
	@echo "LD (loader ELF) $@"
	@$(LD) $(LOADER_LDFLAGS) $(LOADER_OBJS) -o $@

# Link kernel ELF
$(KERNEL_ELF): $(KERNEL_OBJS) $(KERNEL_LINKER_SCRIPT) | $(BUILD_DIR)
	@echo "LD (kernel) $@"
	@$(LD) $(KERNEL_LDFLAGS) $(KERNEL_OBJS) -o $@
	@echo "Kernel built: $@"

# Build ISO image (amd64 only)
.PHONY: iso
iso: $(LOADER_EFI) $(KERNEL_ELF)
ifeq ($(ARCH),amd64)
	@echo "Creating ISO image..."
	@./tools/make-iso.sh $(LOADER_EFI) $(KERNEL_ELF) $(BUILD_DIR)/starkernel.iso
else
	@echo "Error: ISO generation only supported for amd64"
	@exit 1
endif

# Disk image output path
DISK_IMG := out/starkernel.img
DISK_IMG_SIZE_MB ?= 64
ESP_SIZE_MB ?= 32

# Build GPT disk image with FAT32 ESP (no loop devices, no sudo)
.PHONY: disk-image
disk-image: $(LOADER_EFI) $(KERNEL_ELF)
	@echo "Creating GPT disk image with FAT32 ESP..."
	@./scripts/make-disk-image.sh --execute \
		--output $(DISK_IMG) \
		--bootloader $(LOADER_EFI) \
		--kernel $(KERNEL_ELF) \
		--size $(DISK_IMG_SIZE_MB) \
		--esp-size $(ESP_SIZE_MB)

# Build Raspberry Pi 4B image (aarch64 only)
.PHONY: rpi4-image
rpi4-image: $(LOADER_EFI) $(KERNEL_ELF)
ifeq ($(ARCH),aarch64)
	@echo "Creating Raspberry Pi 4B image..."
	@./tools/make-rpi4-image.sh $(LOADER_EFI) $(KERNEL_ELF) $(BUILD_DIR)/starkernel-rpi4.img
else
	@echo "Error: RasPi image generation only supported for aarch64"
	@exit 1
endif

# Launch QEMU with FAT virtual filesystem (development workflow)
# Uses QEMU's fat:rw: feature which presents a directory as a FAT filesystem.
# OVMF can boot this directly without shell intervention.
#
# This is the canonical QEMU method for fast dev iteration:
#   - No loop devices, no root, no disk image rebuild
#   - OVMF loads \EFI\BOOT\BOOTX64.EFI directly
#   - Loader finds \kernel.elf on same filesystem
#
# For real hardware validation, use 'make disk-image' then dd to USB.
.PHONY: qemu
qemu: $(LOADER_EFI) $(KERNEL_ELF)
ifeq ($(ARCH),amd64)
	@echo "=== QEMU ESP Staging ==="
	@mkdir -p $(BUILD_DIR)/esp/EFI/BOOT
	@cp $(LOADER_EFI) $(BUILD_DIR)/esp/EFI/BOOT/BOOTX64.EFI
	@cp $(KERNEL_ELF) $(BUILD_DIR)/esp/kernel.elf
	@echo "  $(BUILD_DIR)/esp/EFI/BOOT/BOOTX64.EFI"
	@echo "  $(BUILD_DIR)/esp/kernel.elf"
	@echo ""
	@echo "=== Launching QEMU (fat: virtual filesystem) ==="
	@if [ -f /usr/share/OVMF/OVMF_VARS_4M.fd ]; then \
		cp /usr/share/OVMF/OVMF_VARS_4M.fd $(BUILD_DIR)/OVMF_VARS.fd; \
	else \
		echo "Error: /usr/share/OVMF/OVMF_VARS_4M.fd not found"; \
		exit 1; \
	fi
	@OVMF_CODE=/usr/share/OVMF/OVMF_CODE_4M.fd; \
	if [ ! -f $$OVMF_CODE ]; then echo "Error: $$OVMF_CODE not found"; exit 1; fi; \
	TMPDIR=$(BUILD_DIR) qemu-system-x86_64 \
		-machine q35,accel=tcg \
		-m 1024 \
		-drive if=pflash,format=raw,readonly=on,file=$$OVMF_CODE \
		-drive if=pflash,format=raw,file=$(BUILD_DIR)/OVMF_VARS.fd \
		-drive format=raw,file=fat:rw:$(BUILD_DIR)/esp \
		-serial stdio \
		-display none \
		-no-reboot
else
	@echo "Error: qemu boot only supported for amd64 currently"
	@exit 1
endif

# Launch QEMU from GPT disk image (closer to real hardware)
# Uses the disk image created by 'make disk-image'.
# OVMF falls to shell, startup.nsh runs after 5-second countdown.
# Use this when you care about disk/partition semantics.
.PHONY: qemu-disk
qemu-disk: disk-image
ifeq ($(ARCH),amd64)
	@echo "=== Launching QEMU from disk image ==="
	@echo "  Image: $(DISK_IMG)"
	@echo "  Boot: OVMF -> shell -> startup.nsh (5s countdown)"
	@echo ""
	@if [ -f /usr/share/OVMF/OVMF_VARS_4M.fd ]; then \
		cp /usr/share/OVMF/OVMF_VARS_4M.fd out/OVMF_VARS.fd; \
	else \
		echo "Error: /usr/share/OVMF/OVMF_VARS_4M.fd not found"; \
		exit 1; \
	fi
	@OVMF_CODE=/usr/share/OVMF/OVMF_CODE_4M.fd; \
	if [ ! -f $$OVMF_CODE ]; then echo "Error: $$OVMF_CODE not found"; exit 1; fi; \
	TMPDIR=out qemu-system-x86_64 \
		-machine q35,accel=tcg \
		-m 1024 \
		-drive if=pflash,format=raw,readonly=on,file=$$OVMF_CODE \
		-drive if=pflash,format=raw,file=out/OVMF_VARS.fd \
		-device qemu-xhci,id=xhci \
		-drive if=none,id=usbdisk,format=raw,file=$(DISK_IMG) \
		-device usb-storage,bus=xhci.0,drive=usbdisk \
		-serial stdio \
		-display none \
		-no-reboot
else
	@echo "Error: qemu-disk only supported for amd64 currently"
	@exit 1
endif

# Launch QEMU with ESP directory (quick iteration, no disk image rebuild)
.PHONY: qemu-esp
qemu-esp: $(LOADER_EFI) $(KERNEL_ELF)
ifeq ($(ARCH),amd64)
	@echo "Preparing FAT ESP directory for QEMU..."
	@rm -rf $(BUILD_DIR)/esp
	@mkdir -p $(BUILD_DIR)/esp/EFI/BOOT
	@cp $(LOADER_EFI) $(BUILD_DIR)/esp/EFI/BOOT/BOOTX64.EFI
	@cp $(KERNEL_ELF) $(BUILD_DIR)/esp/kernel.elf
	@printf "FS0:\\EFI\\BOOT\\BOOTX64.EFI\r\n" > $(BUILD_DIR)/esp/startup.nsh
	@echo "Launching QEMU for amd64 (OVMF pflash + ESP directory)..."
	@# Use the 4MB OVMF build installed on this host
	OVMF_CODE=/usr/share/OVMF/OVMF_CODE_4M.fd; \
	if [ ! -f $$OVMF_CODE ]; then echo "Error: $$OVMF_CODE not found"; exit 1; fi; \
	if [ -f /usr/share/OVMF/OVMF_VARS_4M.fd ]; then \
		cp /usr/share/OVMF/OVMF_VARS_4M.fd $(BUILD_DIR)/OVMF_VARS.fd; \
	else \
		echo "Error: /usr/share/OVMF/OVMF_VARS_4M.fd not found"; \
		exit 1; \
	fi; \
	TMPDIR=$(BUILD_DIR) qemu-system-x86_64 \
		-nodefaults -display none \
		-machine q35,accel=tcg \
		-m 1024 \
		-monitor none \
		-chardev stdio,id=ser0,signal=off \
		-device isa-serial,chardev=ser0,iobase=0x3f8 \
		-chardev file,id=dbg,path=$(BUILD_DIR)/ovmf.log \
		-device isa-debugcon,chardev=dbg,iobase=0x402 \
		-drive if=pflash,format=raw,readonly=on,file=$$OVMF_CODE \
		-drive if=pflash,format=raw,file=$(BUILD_DIR)/OVMF_VARS.fd \
		-drive format=raw,file=fat:rw:$(BUILD_DIR)/esp \
		-no-reboot
else ifeq ($(ARCH),aarch64)
	@echo "Preparing FAT ESP directory for QEMU (aarch64)..."
	@rm -rf $(BUILD_DIR)/esp
	@mkdir -p $(BUILD_DIR)/esp/EFI/BOOT
	@cp $(LOADER_EFI) $(BUILD_DIR)/esp/EFI/BOOT/BOOTAA64.EFI
	@cp $(KERNEL_ELF) $(BUILD_DIR)/esp/kernel.elf
	@printf "FS0:\\EFI\\BOOT\\BOOTAA64.EFI\r\n" > $(BUILD_DIR)/esp/startup.nsh
	@echo "Launching QEMU for aarch64 (virt + UEFI)..."
	@if [ -f /usr/share/AAVMF/AAVMF_CODE.fd ]; then \
		AAVMF_CODE=/usr/share/AAVMF/AAVMF_CODE.fd; \
	elif [ -f /usr/share/qemu-efi-aarch64/QEMU_EFI.fd ]; then \
		AAVMF_CODE=/usr/share/qemu-efi-aarch64/QEMU_EFI.fd; \
	elif [ -f /usr/share/qemu/edk2-aarch64-code.fd ]; then \
		AAVMF_CODE=/usr/share/qemu/edk2-aarch64-code.fd; \
	else \
		echo "Error: aarch64 UEFI firmware not found (AAVMF/edk2). Install qemu-efi-aarch64."; \
		exit 1; \
	fi; \
	TMPDIR=$(BUILD_DIR) qemu-system-aarch64 \
		-machine virt \
		-cpu cortex-a57 \
		-bios $$AAVMF_CODE \
		-drive format=raw,file=fat:rw:$(BUILD_DIR)/esp \
		-serial mon:stdio \
		-nographic \
		-m 2048 \
		-d guest_errors
else ifeq ($(ARCH),riscv64)
	@echo "Preparing FAT ESP directory for QEMU (riscv64)..."
	@rm -rf $(BUILD_DIR)/esp
	@mkdir -p $(BUILD_DIR)/esp/EFI/BOOT
	@cp $(LOADER_EFI) $(BUILD_DIR)/esp/EFI/BOOT/BOOTRISCV64.EFI
	@cp $(KERNEL_ELF) $(BUILD_DIR)/esp/kernel.elf
	@printf "FS0:\\EFI\\BOOT\\BOOTRISCV64.EFI\r\n" > $(BUILD_DIR)/esp/startup.nsh
	@echo "Launching QEMU for riscv64 (virt + UEFI)..."
	@if [ -f /usr/share/qemu-efi-riscv64/QEMU_EFI.fd ]; then \
		EDK2_RISCV=/usr/share/qemu-efi-riscv64/QEMU_EFI.fd; \
	elif [ -f /usr/share/qemu/edk2-riscv64-code.fd ]; then \
		EDK2_RISCV=/usr/share/qemu/edk2-riscv64-code.fd; \
	else \
		echo "Error: riscv64 UEFI firmware not found. Install qemu-efi-riscv64."; \
		exit 1; \
	fi; \
	TMPDIR=$(BUILD_DIR) qemu-system-riscv64 \
		-machine virt \
		-bios $$EDK2_RISCV \
		-drive format=raw,file=fat:rw:$(BUILD_DIR)/esp \
		-serial mon:stdio \
		-nographic \
		-m 256M \
		-d guest_errors
endif

# Launch QEMU with GDB
.PHONY: qemu-gdb
qemu-gdb: $(LOADER_EFI) $(KERNEL_ELF)
ifeq ($(ARCH),amd64)
	@echo "Launching QEMU with GDB server on port 1234..."
	@mkdir -p $(BUILD_DIR)/esp/EFI/BOOT
	@cp $(LOADER_EFI) $(BUILD_DIR)/esp/EFI/BOOT/BOOTX64.EFI
	@cp $(KERNEL_ELF) $(BUILD_DIR)/esp/kernel.elf
	@qemu-system-x86_64 \
		-bios /usr/share/OVMF/OVMF_CODE.fd \
		-drive format=raw,file=fat:rw:$(BUILD_DIR)/esp \
		-serial stdio \
		-m 256M \
		-s -S
	@echo "Waiting for GDB connection on port 1234..."
	@echo "In another terminal, run: gdb $(KERNEL_ELF) -ex 'target remote :1234'"
else ifeq ($(ARCH),riscv64)
	@echo "Launching QEMU with GDB server for RISC-V on port 1234..."
	@qemu-system-riscv64 \
		-M virt \
		-kernel $(LOADER_EFI) \
		-serial stdio \
		-m 128M \
		-s -S
else
	@echo "GDB support for $(ARCH) not yet implemented"
	@exit 1
endif

# Convenience targets
.PHONY: kernel
kernel: all

.PHONY: kernel-all
kernel-all:
	@$(MAKE) -f Makefile.starkernel ARCH=amd64 TARGET=kernel
	@$(MAKE) -f Makefile.starkernel ARCH=aarch64 TARGET=kernel
	@$(MAKE) -f Makefile.starkernel ARCH=riscv64 TARGET=kernel

# Clean
.PHONY: clean-kernel
clean-kernel:
	@echo "Cleaning StarKernel build artifacts..."
	@rm -rf build/*/kernel
	@echo "StarKernel build artifacts cleaned"

.PHONY: info
info:
	@echo "StarKernel Build Configuration"
	@echo "=============================="
	@echo "Architecture:     $(ARCH)"
	@echo "Target:           $(TARGET)"
	@echo "Compiler:         $(CC)"
	@echo "Linker:           $(LD)"
	@echo "Build dir:        $(BUILD_DIR)"
	@echo "Loader linker:    $(LOADER_LINKER_SCRIPT)"
	@echo "Kernel linker:    $(KERNEL_LINKER_SCRIPT)"
	@echo "Loader output:    $(LOADER_EFI)"
	@echo "Kernel output:    $(KERNEL_ELF)"

.PHONY: help
help:
	@echo "StarKernel Build System"
	@echo "======================="
	@echo ""
	@echo "Usage: make -f Makefile.starkernel [ARCH=<arch>] [TARGET=<target>] <target>"
	@echo ""
	@echo "Architectures:"
	@echo "  ARCH=amd64     - x86_64 (default)"
	@echo "  ARCH=aarch64   - ARM64 (Raspberry Pi 4B)"
	@echo "  ARCH=riscv64   - RISC-V 64-bit"
	@echo ""
	@echo "Build targets:"
	@echo "  all            - Build loader + kernel (default)"
	@echo "  kernel         - Same as 'all'"
	@echo "  kernel-all     - Build for all architectures"
	@echo "  disk-image     - Create GPT disk image with FAT32 ESP (out/starkernel.img)"
	@echo "  iso            - Create bootable ISO (amd64 only)"
	@echo "  rpi4-image     - Create RasPi 4B SD card image (aarch64 only)"
	@echo "  clean-kernel   - Clean build artifacts"
	@echo ""
	@echo "QEMU targets:"
	@echo "  qemu           - Boot from disk image (proper GPT/ESP, matches hardware)"
	@echo "  qemu-esp       - Quick boot from ESP directory (no disk image rebuild)"
	@echo "  qemu-gdb       - Launch QEMU with GDB server"
	@echo ""
	@echo "Info targets:"
	@echo "  info           - Show build configuration"
	@echo "  help           - Show this help message"
	@echo ""
	@echo "Examples:"
	@echo "  make -f Makefile.starkernel ARCH=amd64"
	@echo "  make -f Makefile.starkernel ARCH=amd64 disk-image"
	@echo "  make -f Makefile.starkernel ARCH=amd64 qemu"
	@echo "  make -f Makefile.starkernel ARCH=amd64 qemu-esp  # Quick iteration"
	@echo "  make -f Makefile.starkernel ARCH=aarch64 rpi4-image"
	@echo ""
	@echo "To write disk image to USB (DESTRUCTIVE!):"
	@echo "  sudo dd if=out/starkernel.img of=/dev/sdX bs=4M conv=fsync status=progress"
