<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>PolymorphicEquality</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="./rouge-github.css">
<link rel="stylesheet" href="./mlton.css">

</head>
<body class="article">
<div id="mlton-header">
<div id="mlton-header-text">
<h2>
<a href="./Home">
MLton
20241230
</a>
</h2>
</div>
</div>
<div id="header">
<h1>PolymorphicEquality</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_equality_of_ground_types">Equality of ground types</a></li>
<li><a href="#_equality_of_reals">Equality of reals</a></li>
<li><a href="#_equality_of_functions">Equality of functions</a></li>
<li><a href="#_equality_of_immutable_types">Equality of immutable types</a></li>
<li><a href="#_equality_of_mutable_values">Equality of mutable values</a></li>
<li><a href="#_equality_of_datatypes">Equality of datatypes</a></li>
<li><a href="#_implementation">Implementation</a></li>
<li><a href="#_also_see">Also see</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Polymorphic equality is a built-in function in
<a href="StandardML">Standard ML</a> that compares two values of the same type
for equality.  It is specified as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sml"><span class="kr">val</span> <span class="nv">=</span> <span class="p">:</span> <span class="nd">''a</span> <span class="n">*</span> <span class="nd">''a</span> <span class="p">-&gt;</span> <span class="n">bool</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>''a</code> in the specification are
<a href="EqualityTypeVariable">equality type variables</a>, and indicate that
polymorphic equality can only be applied to values of an
<a href="EqualityType">equality type</a>.  It is not allowed in SML to rebind
<code>=</code>, so a programmer is guaranteed that <code>=</code> always denotes polymorphic
equality.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_equality_of_ground_types">Equality of ground types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ground types like <code>char</code>, <code>int</code>, and <code>word</code> may be compared (to values
of the same type).  For example, <code>13 = 14</code> is type correct and yields
<code>false</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_equality_of_reals">Equality of reals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The one ground type that can not be compared is <code>real</code>.  So,
<code>13.0 = 14.0</code> is not type correct.  One can use <code>Real.==</code> to compare
reals for equality, but beware that this has different algebraic
properties than polymorphic equality.</p>
</div>
<div class="paragraph">
<p>See <a href="http://standardml.org/Basis/real.html" class="bare">http://standardml.org/Basis/real.html</a> for a discussion of why
<code>real</code> is not an equality type.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_equality_of_functions">Equality of functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Comparison of functions is not allowed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_equality_of_immutable_types">Equality of immutable types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Polymorphic equality can be used on <a href="Immutable">immutable</a> values like
tuples, records, lists, and vectors.  For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(1, 2, 3) = (4, 5, 6)</pre>
</div>
</div>
<div class="paragraph">
<p>is a type-correct expression yielding <code>false</code>, while</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[1, 2, 3] = [1, 2, 3]</pre>
</div>
</div>
<div class="paragraph">
<p>is type correct and yields <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Equality on immutable values is computed by structure, which means
that values are compared by recursively descending the data structure
until ground types are reached, at which point the ground types are
compared with primitive equality tests (like comparison of
characters).  So, the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[1, 2, 3] = [1, 1 + 1, 1 + 1 + 1]</pre>
</div>
</div>
<div class="paragraph">
<p>is guaranteed to yield <code>true</code>, even though the lists may occupy
different locations in memory.</p>
</div>
<div class="paragraph">
<p>Because of structural equality, immutable values can only be compared
if their components can be compared.  For example, <code>[1, 2, 3]</code> can be
compared, but <code>[1.0, 2.0, 3.0]</code> can not.  The SML type system uses
<a href="EqualityType">equality types</a> to ensure that structural equality is
only applied to valid values.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_equality_of_mutable_values">Equality of mutable values</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In contrast to immutable values, polymorphic equality of
<a href="Mutable">mutable</a> values (like ref cells and arrays) is performed by
pointer comparison, not by structure.  So, the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ref 13 = ref 13</pre>
</div>
</div>
<div class="paragraph">
<p>is guaranteed to yield <code>false</code>, even though the ref cells hold the
same contents.</p>
</div>
<div class="paragraph">
<p>Because equality of mutable values is not structural, arrays and refs
can be compared <em>even if their components are not equality types</em>.
Hence, the following expression is type correct (and yields true).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sml"><span class="kr">let</span>
   <span class="kr">val</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">ref</span> <span class="mf">13.0</span>
<span class="kr">in</span>
   <span class="n">r</span> <span class="p">=</span> <span class="n">r</span>
<span class="kr">end</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_equality_of_datatypes">Equality of datatypes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Polymorphic equality of datatypes is structural.  Two values of the
same datatype are equal if they are of the same <a href="Variant">variant</a> and
if the <a href="Variant">variant</a>&rsquo;s arguments are equal (recursively).  So,
with the datatype</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sml"><span class="kr">datatype</span> <span class="kt">t</span> <span class="p">=</span> <span class="nc">A</span> <span class="p">|</span> <span class="nc">B</span> <span class="kr">of</span> <span class="n">t</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>then <code>B (B A) = B A</code> is type correct and yields <code>false</code>, while <code>A = A</code>
and <code>B A = B A</code> yield <code>true</code>.</p>
</div>
<div class="paragraph">
<p>As polymorphic equality descends two values to compare them, it uses
pointer equality whenever it reaches a mutable value.  So, with the
datatype</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sml"><span class="kr">datatype</span> <span class="kt">t</span> <span class="p">=</span> <span class="nc">A</span> <span class="kr">of</span> <span class="n">int</span> <span class="n">ref</span> <span class="p">|</span> <span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>then <code>A (ref 13) = A (ref 13)</code> is type correct and yields <code>false</code>,
because the pointer equality on the two ref cells yields <code>false</code>.</p>
</div>
<div class="paragraph">
<p>One weakness of the SML type system is that datatypes do not inherit
the special property of the <code>ref</code> and <code>array</code> type constructors that
allows them to be compared regardless of their component type.  For
example, after declaring</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sml"><span class="kr">datatype</span> <span class="nd">'a</span> <span class="kt">t</span> <span class="p">=</span> <span class="nc">A</span> <span class="kr">of</span> <span class="nd">'a</span> <span class="n">ref</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>one might expect to be able to compare two values of type <code>real t</code>,
because pointer comparison on a ref cell would suffice.
Unfortunately, the type system can only express that a user-defined
datatype <a href="AdmitsEquality">admits equality</a> or not.  In this case, <code>t</code>
admits equality, which means that <code>int t</code> can be compared but that
<code>real t</code> can not.  We can confirm this with the program</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sml"><span class="kr">datatype</span> <span class="nd">'a</span> <span class="kt">t</span> <span class="p">=</span> <span class="nc">A</span> <span class="kr">of</span> <span class="nd">'a</span> <span class="n">ref</span>
<span class="kr">fun</span> <span class="nf">f</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">real</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">real</span> <span class="n">t</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span> <span class="p">=</span> <span class="n">y</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>on which MLton reports the following error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Error: z.sml 2.32-2.36.
  Function applied to incorrect argument.
    expects: [&lt;equality&gt;] t * [&lt;equality&gt;] t
    but got: [real] t * [real] t
    in: = (x, y)</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation">Implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Polymorphic equality is implemented by recursively descending the two
values being compared, stopping as soon as they are determined to be
unequal, or exploring the entire values to determine that they are
equal.  Hence, polymorphic equality can take time proportional to the
size of the smaller value.</p>
</div>
<div class="paragraph">
<p>MLton uses some optimizations to improve performance.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When computing structural equality, first do a pointer comparison.
If the comparison yields <code>true</code>, then stop and return <code>true</code>, since
the structural comparison is guaranteed to do so.  If the pointer
comparison fails, then recursively descend the values.</p>
</li>
<li>
<p>If a datatype is an enum (e.g. <code>datatype t = A | B | C</code>), then a
single comparison suffices to compare values of the datatype.  No case
dispatch is required to determine whether the two values are of the
same <a href="Variant">variant</a>.</p>
</li>
<li>
<p>When comparing a known constant non-value-carrying
<a href="Variant">variant</a>, use a single comparison.  For example, the
following code will compile into a single comparison for <code>A = x</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sml"><span class="kr">datatype</span> <span class="kt">t</span> <span class="p">=</span> <span class="nc">A</span> <span class="p">|</span> <span class="nc">B</span> <span class="p">|</span> <span class="nc">C</span> <span class="kr">of</span> <span class="p">...</span>
<span class="kr">fun</span> <span class="nf">f</span> <span class="n">x</span> <span class="p">=</span> <span class="p">...</span> <span class="kr">if</span> <span class="n">A</span> <span class="p">=</span> <span class="n">x</span> <span class="kr">then</span> <span class="p">...</span></code></pre>
</div>
</div>
</li>
<li>
<p>When comparing a small constant <code>IntInf.int</code> to another
<code>IntInf.int</code>, use a single comparison against the constant.  No case
dispatch is required.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_also_see">Also see</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="AdmitsEquality">AdmitsEquality</a></p>
</li>
<li>
<p><a href="EqualityType">EqualityType</a></p>
</li>
<li>
<p><a href="EqualityTypeVariable">EqualityTypeVariable</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="mlton-footer">
<div id="mlton-footer-text">
<div>
Last updated Thu Oct 21 15:53:06 2021 -0400 by Matthew Fluet.
<a href="https://github.com/MLton/mlton/commits/master/doc/guide/src/PolymorphicEquality.adoc">Log</a>
<a href="https://github.com/MLton/mlton/edit/master/doc/guide/src/PolymorphicEquality.adoc">Edit</a>
</div>
</div>
</body>
</html>