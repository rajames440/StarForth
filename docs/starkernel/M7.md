# M7: VM Integration â€” Hardened Implementation Plan

**Status:** Step 1 â€” Config centralization in progress
**Last Updated:** 2025-12-26
**Author:** Codex (handoff from Claude; reviewed by Captain Bob)

### Baseline Build Commands (2025-12-26T20:37Z)
- Hosted reference (rerun 2025-12-26T20:34Z):  
  ```bash
  make
  ```
  Last lines: `âœ“ Build complete: build/amd64/standard/starforth ...`
- Kernel parity harness (rerun 2025-12-26T20:36Z):  
  ```bash
  STARFORTH_ENABLE_VM=1 PARITY_MODE=1 make -f Makefile.starkernel qemu
  ```
  Build succeeds; QEMU log still halts at the parity page fault (latest serial dump captured under â€œKernel Log â€” 2025-12-26T20:37Zâ€).

### Progress Update â€” 2025-12-26 (Codex)
- âœ… Step 0 complete: both hosted + kernel builds re-run, log captured, no regressions relative to prior PF halt.
- ðŸ§­ Step 1 plan locked (see â€œRefactor Plan â€” 2025-12-26â€ below); execution now focused on centralizing feature toggles without behavior changes.

### Step 1 â€” Config Centralization (2025-12-26T20:46Z)
- Created `include/starforth_config.h` as the single definition point for `STRICT_PTR`, cache/pipeline toggles, adaptive knobs, and heartbeat cadence settings. VM headers now include it directly, so the VM core no longer sprinkles `#ifndef` defaults.
- Hosted + kernel Makefiles force-include the config header and only emit `-D` overrides when the caller specifies a variable (kernel still forces `HEARTBEAT_THREAD_ENABLED=0`). All duplicate `?=` defaults were removed; shared helper logic now injects overrides consistently.
- Kernel VM build inherits the same header by default while `Makefile.starkernel` applies only the overrides it truly owns.
- Rebuilt both targets:
  - Hosted: `make`
  - Kernel parity harness: `STARFORTH_ENABLE_VM=1 PARITY_MODE=1 timeout 60 make -f Makefile.starkernel qemu`
- Result: both builds succeed; kernel still halts at the parity page fault (`RIP=CR2=0xa0000`, see Kernel Log 2025-12-26T20:37Z) which is our current known-good failure point.

### Step 2 â€” HAL Boundary (2025-12-26T21:17Z)
- Established the kernel-only HAL surface at `include/starkernel/hal/hal.h` with alloc/free, time, heartbeat, console, panic, and XT validation stubs; implementations now live in `src/starkernel/hal/hal.c` alongside the host-services shim (`host_services.c` moved out of `src/starkernel/vm/hal`).
- All kernel VM glue (bootstrap + `SYSTEM-WORDS` detours) includes the new HAL header, and the old `starkernel/vm/hal` tree was removed so VM core cannot reach kernel internals directly.
- `Makefile.starkernel` now pulls HAL sources via the existing `$(wildcard $(KERNEL_SRC)/hal/*.c)` sweep, so thereâ€™s a single definition point for HAL wiring regardless of LOADER vs kernel objects.
- Rebuilt + re-ran both reference commands to confirm zero semantic change:
  - Hosted: `make`
  - Kernel parity harness: `STARFORTH_ENABLE_VM=1 PARITY_MODE=1 timeout 60 make -f Makefile.starkernel qemu`
- Result: hosted build unchanged; kernel still reaches the known #PF after FORTH-79 registration (see updated log). Parity halt remains the next bugfix target.

### Step 3 â€” VM Glue Relocation (2025-12-26T21:31Z)
- Moved every kernel-only VM integration unit under `src/starkernel/vm/`: PMM arena management now lives in `vm/arena.c`, parity collection is `vm/parity.c`, and the libc shim sits under `vm/host/shim.c`. The parity header likewise moved to `include/starkernel/vm/parity.h`, and kernel_main now consumes VM APIs exclusively from the `include/starkernel/vm/` tree.
- Updated `Makefile.starkernel` to point at the relocated sources (`vm/arena.c`, `vm/parity.c`, `vm/host/shim.c`) so both the loader and the kernel binaries share the same integration layer.
- Ran hosted + kernel builds again (same commands as above); both succeed with identical runtime behavior (kernel parity harness still halts at the known `RIP=CR2=0x000a0000` fault).

### Step 4 â€” Header Isolation (2025-12-26T21:38Z)
- Lifted `VMHostServices` into the shared tree (`include/vm_host.h`) so the VM core no longer includes any `include/starkernel/*` header. Kernel HAL code now includes the same header, keeping the interface single-sourced.
- `vm_init_with_host()` allocates VM memory strictly through the host-service hook; on kernel builds the HAL allocator intercepts requests matching the arena size and routes them through the PMM-backed arena helpers. This removes the last kernel-specific externs from `src/vm.c`.
- Rebuilt hosted + kernel targets to confirm no behavioral changes (same commands as above); kernel still halts at the known parity fault, which remains the next debugging focus.

### Refactor Plan â€” 2025-12-26
| Step | What moves | Why |
|------|------------|-----|
| 1 | Create `include/starforth_config.h`, funnel all VM feature toggles (cache/pipeline/heartbeat + adaptive knobs) through it, make Makefiles send overrides only | Single source of truth for VM build options before touching HAL/VM wiring |
| 2 | Stand up `include/src/starkernel/hal/` scaffolding + minimal HAL API (alloc/free/time/console/panic/XTs) | Establish physical boundary before code motion |
| 3 | Relocate kernel bootstrap/parity glue under `src/starkernel/vm/` w/ matching headers | Canonical placement for kernel-only VM glue; kernel_main stops reaching into VM internals |
| 4 | Purge kernel headers from VM core, route services via HostServices/HAL | Enforce hosted/kernel split structurally |
| 5 | Finalize build-option taxonomy + â€œBuild Options Mapâ€ table | Document ownership/definition for every flag, prune duplicates, align defaults |
| 6 | Implement HAL `hal_is_executable_ptr()` + logging for XT validation | Deterministic + kernel-aware XT vetting |
| 7 | Full rebuild/test sweep; update M7.md with outcomes + blockers if any | Freeze Step 1-6 work before moving to new features |

Progress will be annotated per-step inside this doc (what moved, commands, blockers).

### Progress Update â€” 2025-12-26 (Claude)
- Host services instrumentation now repatches kernel function pointers post-relocation (`sk_host_init` + shim malloc warnings) so VM-owned allocations always flow through the HAL hooks before parity runs. This resolved the earlier IFETCH @ `0x4d64` crash that happened before the FORTH-79 modules even registered.
- A VMM-aware `vm_xt_is_valid()` replaced the linker-range guard, so module entry points are validated by their executable mappings (NX clear) instead of raw addresses; every FORTH-79 module now gets through the registration gate deterministically.
- VM bootstrap/parity lives entirely under `src/starkernel/vm/` with the shared kernel HAL (`src/starkernel/hal/hal.c`) supplying memory/time/console hooks, the required `TICKS`, `HB`, and `YIELD` words, and a deterministic â€œ`1 2 +`â€ smoke script before parity collection. The latest run still trips a #PF while `register_arithmetic_words` executes (`RIP=CR2=0x000a0000`), so the next blocker is debugging that low-page execution attempt before we can emit the updated parity packet.

---

## Overview

M7 brings the StarForth VM into the kernel. Success is measured by **parity** â€” the kernel VM must produce structurally identical results to hosted StarForth.

This plan incorporates fixes for 7 identified landmines that would otherwise waste debugging time.

---

## Sub-Milestones

### M7.1a: Bootstrap Parity-Ready (No Output)

**Goal:** VM initializes, dictionary populated, bootstrap verifiable via silent self-check.

**Exit Criteria:**
- Bootstrap returns `BOOTSTRAP_OK`
- Summary packet matches hosted:
  - `word_count` (number of dictionary entries)
  - `here_offset` (dictionary usage in bytes)
  - `latest_word_id` (stable ID of most recent word)
  - `header_hash64` (canonical dictionary hash)

**NO printing required.** If sanity check desired: execute `1 2 +` and assert `vm->data_stack[vm->dsp] == 3` from kernel code.

---

### M7.1b: POST Parity

**Goal:** Full test suite runs with identical results to hosted StarForth.

**Exit Criteria:**
- `tests_total/passed/failed/skipped/errors` match hosted exactly
- Canonical dictionary hash matches hosted
- Rolling window hash matches (if inputs deterministic)

---

## Non-Negotiables (LLM Instructions)

**Claude / Codex / All LLMs:**

1. **NO global mallocâ†’kmalloc sweep.** Allocation goes through `vm->host.alloc/free` hooks only.

2. **VM arena MUST be PMM-backed contiguous pages**, not a single giant heap allocation.

3. **Dictionary hashing MUST be canonicalized** â€” no raw pointers, no padding, no runtime fields.

4. **Tests run under deterministic time** â€” fake clock for parity mode (both hosted and kernel).

5. **NO new subsystems** â€” no threads, no scheduler, no devices. Single-thread, polled serial only.

6. **Stubs return SUCCESS, not failure** â€” pthread_create does nothing but returns 0.

7. **Test modules gated by `STARFORTH_ENABLE_TESTS`** â€” not in normal kernel image.

---

## Normative Rules (Frozen)

### Rule 1: word_id Assignment (Monotonic)

`word_id` is assigned as a strictly monotonic creation index:

```
word_id = creation_index, starting at 0
```

**Independent of:**
- Allocation address
- Build order variance
- Hash table iteration order
- Host vs kernel environment

**Invariant:** If hosted assigns word_id=42 to `DUP`, kernel assigns word_id=42 to `DUP`.

### Rule 2: Colon Body Hashing (No Absolute Addresses)

When hashing compiled (colon) word bodies:

- Hash the `word_id` of each called word, NOT the XT address
- Ignore literal cell addresses (hash the literal value only)
- Normalize control flow markers to relative offsets

**Rule:** If two definitions behave identically, their canonical hash MUST match regardless of memory placement.

### Rule 3: Dictionary Traversal Order (Creation Order)

Canonical dictionary traversal is **creation order** (oldest â†’ newest):

- Independent of `link` pointer direction
- Independent of memory layout
- Deterministic across all builds

**Implementation:** Build array from `latestâ†’link` chain, then iterate in reverse.

---

## Architecture

### VM Arena Allocation (Landmine #1 Fix)

**Problem:** `kmalloc(5MB)` fragments heap, causes subtle allocator bugs.

**Solution:** Allocate VM arena from PMM as contiguous pages.

```c
// src/starkernel/vm/arena.c

#define VM_ARENA_PAGES ((VM_MEMORY_SIZE + PMM_PAGE_SIZE - 1) / PMM_PAGE_SIZE)

int sk_vm_arena_alloc(VM *vm) {
    // Allocate contiguous physical pages
    uint64_t paddr = pmm_alloc_contiguous(VM_ARENA_PAGES);
    if (paddr == 0) {
        return -1;  // Out of memory
    }

    // Map pages RW, NX into virtual address space
    uint64_t vaddr = VMM_VM_ARENA_BASE;  // Define a reserved VA range
    for (size_t i = 0; i < VM_ARENA_PAGES; i++) {
        vmm_map_page(vaddr + i * PMM_PAGE_SIZE,
                     paddr + i * PMM_PAGE_SIZE,
                     VMM_FLAG_WRITABLE | VMM_FLAG_NX);
    }

    vm->memory = (uint8_t *)(uintptr_t)vaddr;
    return 0;
}
```

### Host Allocator Hooks (Landmine #2 Fix)

**Problem:** Global malloc replacement is invasive and error-prone.

**Solution:** Host allocator function pointers inside VM structure.

```c
// include/vm_host.h

typedef void* (*sk_alloc_fn)(size_t size, size_t align);
typedef void  (*sk_free_fn)(void *ptr);
typedef uint64_t (*sk_time_fn)(void);

typedef struct {
    sk_alloc_fn alloc;
    sk_free_fn  free;
    sk_time_fn  monotonic_ns;
} VMHostServices;

// In VM struct (or passed to init):
// VMHostServices host;
```

**Hosted:**
```c
static void* hosted_alloc(size_t size, size_t align) {
    (void)align;
    return malloc(size);
}
static void hosted_free(void *ptr) { free(ptr); }
static uint64_t hosted_time(void) { return sf_monotonic_ns(); }

VMHostServices hosted_services = {
    .alloc = hosted_alloc,
    .free = hosted_free,
    .monotonic_ns = hosted_time
};
```

**Kernel:**
```c
static void* kernel_alloc(size_t size, size_t align) {
    return kmalloc_aligned(size, align);
}
static void kernel_free(void *ptr) { kfree(ptr); }
static uint64_t kernel_time(void) {
    // For parity mode, return deterministic value
#if PARITY_MODE
    static uint64_t fake_ns = 0;
    return fake_ns += 1000;  // 1Î¼s per call
#else
    return arch_read_timestamp() * timer_ns_per_tick();
#endif
}

VMHostServices kernel_services = {
    .alloc = kernel_alloc,
    .free = kernel_free,
    .monotonic_ns = kernel_time
};
```

### Canonical Dictionary Hash (Landmine #4 Fix)

**Problem:** Raw memory hash includes pointers, padding, runtime fields â€” will never match.

**Solution:** Hash only structural fields in traversal order.

**DictEntry fields to hash:**
| Field | Include? | Reason |
|-------|----------|--------|
| `link` | NO | Raw pointer |
| `func` | NO | Function pointer |
| `flags` | YES | Structural attribute |
| `name_len` | YES | Structural |
| `name[]` | YES | Word identity |
| `execution_heat` | NO | Runtime state |
| `acl_default` | YES | Structural attribute |
| `word_id` | YES | Stable identifier |
| `physics` | NO | Runtime metadata |
| `transition_metrics` | NO | Pointer |

**For colon definitions, also hash:**
- Body length (bytes from DF to HERE at definition time)
- Body content as relative offsets (word_id of each called word)

```c
// src/starkernel/vm/parity.c

static uint64_t fnv1a_64(const uint8_t *data, size_t len, uint64_t hash) {
    for (size_t i = 0; i < len; i++) {
        hash ^= data[i];
        hash *= 0x100000001B3ULL;
    }
    return hash;
}

uint64_t sk_dict_canonical_hash(VM *vm) {
    uint64_t hash = 0xCBF29CE484222325ULL;  // FNV offset basis

    // Traverse dictionary in reverse order (oldest to newest)
    // Build temporary array of entries, then iterate
    DictEntry *entries[DICTIONARY_SIZE];
    uint32_t count = 0;

    for (DictEntry *e = vm->latest; e != NULL; e = e->link) {
        if (count < DICTIONARY_SIZE) {
            entries[count++] = e;
        }
    }

    // Hash in reverse (oldest first for determinism)
    for (int i = (int)count - 1; i >= 0; i--) {
        DictEntry *e = entries[i];

        // Hash structural fields only
        hash = fnv1a_64(&e->flags, 1, hash);
        hash = fnv1a_64(&e->name_len, 1, hash);
        hash = fnv1a_64((uint8_t *)e->name, e->name_len, hash);
        hash = fnv1a_64(&e->acl_default, 1, hash);
        hash = fnv1a_64((uint8_t *)&e->word_id, sizeof(e->word_id), hash);

        // For colon definitions, hash body as word_id sequence
        if (e->flags & WORD_COMPILED) {
            cell_t *df = vm_dictionary_get_data_field(e);
            if (df) {
                vaddr_t body_addr = (vaddr_t)(uint64_t)(*df);
                // Hash body word IDs (implementation detail)
                // ... traverse threaded code, hash each word_id ...
            }
        }
    }

    return hash;
}
```

### Deterministic Time for Parity (Landmine #6 Fix)

**Problem:** Real time differs between hosted and kernel runs.

**Solution:** Fake clock for parity mode.

```c
// Build flag: -DPARITY_MODE=1

#if PARITY_MODE
// Deterministic time: increments by 1000ns per call
static uint64_t parity_fake_ns = 0;
uint64_t sf_monotonic_ns(void) {
    return parity_fake_ns += 1000;
}
#endif
```

**Hosted parity baseline:**
```bash
# Build hosted with parity mode
make PARITY_MODE=1 standard
./build/amd64/standard/starforth --run-tests --parity
```

**Kernel parity:**
```bash
# Build kernel with parity mode
make -f Makefile.starkernel PARITY_MODE=1 kernel
# Run in QEMU and compare output
```

### Stub Success, Not Failure (Landmine #5 Fix)

**Problem:** pthread_create returning -1 may cause abort.

**Solution:** Stubs succeed silently, do nothing.

```c
// src/starkernel/hal/host_services.c

#ifdef __STARKERNEL__

// Mutex: no-op but returns success
int sf_mutex_init(sf_mutex_t *m) { (void)m; return 0; }
int sf_mutex_lock(sf_mutex_t *m) { (void)m; return 0; }
int sf_mutex_unlock(sf_mutex_t *m) { (void)m; return 0; }
void sf_mutex_destroy(sf_mutex_t *m) { (void)m; }

// Thread: compile out entirely
// In vm.c, wrap thread creation:
#if HEARTBEAT_HAS_THREADS
// ... thread code ...
#endif
// In kernel build: HEARTBEAT_HAS_THREADS=0

#endif
```

### Gated Test Modules (Landmine #7 Fix)

**Problem:** Importing all test code bloats kernel.

**Solution:** Gate behind `STARFORTH_ENABLE_TESTS`.

```makefile
# Makefile.starkernel

# M7.1a: Core VM only
VM_CORE_SOURCES = \
    src/starkernel/vm/arena.c \
    src/starkernel/hal/host_services.c \
    src/starkernel/vm/parity.c \
    src/vm.c \
    src/word_registry.c \
    src/word_source/*.c

# M7.1b: Add tests only when needed
ifdef STARFORTH_ENABLE_TESTS
VM_SOURCES = $(VM_CORE_SOURCES) \
    src/test_runner/test_runner.c \
    src/test_runner/modules/*.c
KERNEL_CFLAGS += -DSTARFORTH_ENABLE_TESTS=1
else
VM_SOURCES = $(VM_CORE_SOURCES)
endif
```

---

## Parity Packet Structure

```c
// include/starkernel/vm/parity.h
// now include/starkernel/vm/parity.h

typedef struct {
    // M7.1a fields (bootstrap)
    uint32_t word_count;           // Number of dictionary entries
    uint32_t here_offset;          // vm->here (bytes used)
    uint32_t latest_word_id;       // vm->latest->word_id
    uint64_t header_hash64;        // Canonical dictionary hash

    // M7.1b fields (POST)
    uint32_t tests_total;
    uint32_t tests_passed;
    uint32_t tests_failed;
    uint32_t tests_skipped;
    uint32_t tests_errors;

    // Optional (if rolling window is deterministic)
    uint64_t window_hash64;
} ParityPacket;

// Collection function
void sk_parity_collect(VM *vm, ParityPacket *out);

// Print as hex line (for serial comparison)
void sk_parity_print(const ParityPacket *pkt);
```

**Output format:**
```
PARITY:M7.1a word_count=245 here=0x1A2B3C latest_id=244 hash=0xDEADBEEF12345678
PARITY:M7.1b tests=936 pass=936 fail=0 skip=0 err=0
PARITY:MATCH or PARITY:MISMATCH
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `include/vm_host.h` | Host services interface |
| `src/starkernel/hal/host_services.c` | Kernel host service implementations |
| `src/starkernel/vm/arena.c` | Kernel VM initialization (PMM arena) |
| `include/starkernel/vm/parity.h` | Parity packet structure |
| `src/starkernel/vm/parity.c` | Canonical hash + parity collection |

## Files to Modify

| File | Changes |
|------|---------|
| `include/vm.h` | Add `VMHostServices *host` field |
| `src/vm.c` | Use `vm->host->alloc()` instead of `malloc()` |
| `src/word_registry.c` | Conditional compilation for kernel |
| `Makefile.starkernel` | Add VM sources, PARITY_MODE, STARFORTH_ENABLE_TESTS |
| `src/starkernel/kernel_main.c` | Call `sk_vm_init()`, collect parity |

---

## Implementation Order

### Week 1: M7.1a Bootstrap

**Day 1:** Create `vm_host.h` + kernel host-service shim (`hal/host_services.c`)
**Day 2:** Create `vm/arena.c` with PMM-backed arena allocation
**Day 3:** Modify `vm.c` to use host hooks (guarded by `__STARKERNEL__`)
**Day 4:** Wire up dictionary registration, verify compilation
**Day 5:** Implement parity collection, compare hosted vs kernel summary

### Week 2: M7.1b POST

**Day 1:** Port test runner with `STARFORTH_ENABLE_TESTS` gate
**Day 2:** Fix any word modules that fail to compile for kernel
**Day 3:** Implement deterministic time mode for parity
**Day 4:** Run full POST in QEMU, compare to hosted baseline
**Day 5:** Debug any parity mismatches

---

## Validation Commands

**Hosted baseline:**
```bash
make clean
make PARITY_MODE=1 standard
./build/amd64/standard/starforth --run-tests --parity > /tmp/hosted_parity.txt
```

**Kernel under test:**
```bash
make -f Makefile.starkernel clean-kernel
make -f Makefile.starkernel PARITY_MODE=1 STARFORTH_ENABLE_TESTS=1 kernel
# Capture QEMU output
timeout 60 make -f Makefile.starkernel qemu 2>&1 | tee /tmp/kernel_out.txt
grep "^PARITY:" /tmp/kernel_out.txt > /tmp/kernel_parity.txt
```

**Compare:**
```bash
diff /tmp/hosted_parity.txt /tmp/kernel_parity.txt && echo "PARITY OK" || echo "PARITY MISMATCH"
```

---

## Risk Mitigations

| Risk | Mitigation |
|------|------------|
| Heap fragmentation | VM arena is PMM-backed, not heap |
| Pointer-in-hash | Canonical hash excludes all pointers |
| Time divergence | PARITY_MODE uses fake deterministic clock |
| Thread stubs break caller | Stubs return success, do nothing |
| Kernel bloat from tests | Tests gated by STARFORTH_ENABLE_TESTS |
| Allocator semantics differ | All allocation via host hooks |

---

## Success Criteria

**M7.1a PASS:**
```
PARITY:M7.1a word_count=245 here=0x1A2B3C latest_id=244 hash=0xDEADBEEF12345678
(matches hosted exactly)
```

**M7.1b PASS:**
```
PARITY:M7.1b tests=936 pass=936 fail=0 skip=0 err=0
PARITY:MATCH
```

---

## Kernel Log â€” 2025-12-26T20:37Z (Codex)

```
Preparing FAT ESP directory for QEMU...
Launching QEMU for amd64 (OVMF pflash + ESP)...
OVMF_CODE=/usr/share/OVMF/OVMF_CODE_4M.fd; \
if [ ! -f $OVMF_CODE ]; then echo "Error: $OVMF_CODE not found"; exit 1; fi; \
if [ -f /usr/share/OVMF/OVMF_VARS_4M.fd ]; then \
	cp /usr/share/OVMF/OVMF_VARS_4M.fd build/amd64/kernel/OVMF_VARS.fd; \
else \
	echo "Error: /usr/share/OVMF/OVMF_VARS_4M.fd not found"; \
	exit 1; \
fi; \
TMPDIR=build/amd64/kernel qemu-system-x86_64 \
	-nodefaults -display none \
	-machine q35,accel=tcg \
	-m 1024 \
	-monitor none \
	-chardev stdio,id=ser0,signal=off \
	-device isa-serial,chardev=ser0,iobase=0x3f8 \
	-chardev file,id=dbg,path=build/amd64/kernel/ovmf.log \
	-device isa-debugcon,chardev=dbg,iobase=0x402 \
	-drive if=pflash,format=raw,readonly=on,file=$OVMF_CODE \
	-drive if=pflash,format=raw,file=build/amd64/kernel/OVMF_VARS.fd \
	-drive format=raw,file=fat:rw:build/amd64/kernel/esp \
	-no-reboot
BdsDxe: loading Boot0001 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)
BdsDxe: starting Boot0001 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)
StarKernel UEFI Loader
Loading kernel from ESP...
RAW SERIAL UP
Monolithic build - kernel linked directly
Collecting boot information...
EBS...

EBS OK

Calling kernel_main (monolithic)...
IDT installed.

   _____ _             _  __                    _
  / ____| |           | |/ /                   | |
 | (___ | |_ __ _ _ __| ' / ___ _ __ _ __   ___| |
  \___ \| __/ _` | '__|  < / _ \ '__| '_ \ / _ \ |
  ____) | || (_| | |  | . \  __/ |  | | | |  __/ |
 |_____/ \__\__,_|_|  |_|\_\___|_|  |_| |_|\___|_

StarKernel v0.1.0 - FORTH Microkernel
Architecture: amd64
Build: Dec 26 2025 15:36:07

UEFI BootServices: EXITED

=== StarKernel Boot Information ===
Memory map entries: 117
Total memory: 1023 MB
Usable memory: 974 MB
===================================

PMM initialized.
... (PMM/VMM/heap/timer output unchanged from prior run) ...

VM: bootstrap parity...
VM arena allocated: 0xffff900000000000
 (5 MB)
Registering FORTH-79 Standard word set...
Registering FORTH-79 arithmetic words...

=== INTERRUPT/EXCEPTION ===
Vector : 14 (0x000000000000000e)
Error  : 0x0000000000000010
RIP    : 0x00000000000a0000
CR2    : 0x00000000000a0000
Fault: Page Fault (#PF)
PF EC  : NP R SUP IFETCH
Halting.
qemu-system-x86_64: terminating on signal 15 from pid 147524 (timeout)
make: *** [Makefile.starkernel:327: qemu] Terminated
```

## Kernel Log â€” 2025-12-26T20:29Z

```
Preparing FAT ESP directory for QEMU...
Launching QEMU for amd64 (OVMF pflash + ESP)...
OVMF_CODE=/usr/share/OVMF/OVMF_CODE_4M.fd; \
if [ ! -f $OVMF_CODE ]; then echo "Error: $OVMF_CODE not found"; exit 1; fi; \
if [ -f /usr/share/OVMF/OVMF_VARS_4M.fd ]; then \
	cp /usr/share/OVMF/OVMF_VARS_4M.fd build/amd64/kernel/OVMF_VARS.fd; \
else \
	echo "Error: /usr/share/OVMF/OVMF_VARS_4M.fd not found"; \
	exit 1; \
fi; \
TMPDIR=build/amd64/kernel qemu-system-x86_64 \
	-nodefaults -display none \
	-machine q35,accel=tcg \
	-m 1024 \
	-monitor none \
	-chardev stdio,id=ser0,signal=off \
	-device isa-serial,chardev=ser0,iobase=0x3f8 \
	-chardev file,id=dbg,path=build/amd64/kernel/ovmf.log \
	-device isa-debugcon,chardev=dbg,iobase=0x402 \
	-drive if=pflash,format=raw,readonly=on,file=$OVMF_CODE \
	-drive if=pflash,format=raw,file=build/amd64/kernel/OVMF_VARS.fd \
	-drive format=raw,file=fat:rw:build/amd64/kernel/esp \
	-no-reboot
BdsDxe: loading Boot0001 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)
BdsDxe: starting Boot0001 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)
StarKernel UEFI Loader
Loading kernel from ESP...
RAW SERIAL UP
Monolithic build - kernel linked directly
Collecting boot information...
EBS...

EBS OK

Calling kernel_main (monolithic)...
IDT installed.

   _____ _             _  __                    _
  / ____| |           | |/ /                   | |
 | (___ | |_ __ _ _ __| ' / ___ _ __ _ __   ___| |
  \___ \| __/ _` | '__|  < / _ \ '__| '_ \ / _ \ |
  ____) | || (_| | |  | . \  __/ |  | | | |  __/ |
 |_____/ \__\__,_|_|  |_|\_\___|_|  |_| |_|\___|_

StarKernel v0.1.0 - FORTH Microkernel
Architecture: amd64
Build: Dec 26 2025 15:26:04

... (PMM/VMM/heap/timer bring-up omitted) ...

VM: bootstrap parity...
VM arena allocated: 0xffff900000000000
 (5 MB)
Registering FORTH-79 Standard word set...
Registering FORTH-79 arithmetic words...

=== INTERRUPT/EXCEPTION ===
Vector : 14 (0x000000000000000e)
Error  : 0x0000000000000010
RIP    : 0x00000000000a0000
CR2    : 0x00000000000a0000
Fault: Page Fault (#PF)
PF EC  : NP R SUP IFETCH
Halting.
qemu-system-x86_64: terminating on signal 15 from pid 145563 (timeout)
make: *** [Makefile.starkernel:327: qemu] Terminated
```

---

*This plan incorporates fixes for all 7 identified landmines. No work proceeds until Captain Bob approves.*
