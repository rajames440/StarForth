# M7 — Phase A Execution Checklist (Codex)

STATUS: ACTIVE  
GOAL: Reach parity snapshot without IFETCH fault

---

## A. Invariants (DO NOT VIOLATE)

- [ ] Hosted StarForth (`master`) is canonical
- [ ] Kernel VM branch only; do not merge into master
- [ ] ANSI C99, freestanding
- [ ] No libc usage
- [ ] No interpreter during bootstrap
- [ ] No colon defs or literals in base dictionary
- [ ] Entire FORTH-79 dictionary implemented as C primitives
- [ ] Direct-threaded VM only
- [ ] XT validity based on ownership, not address windows

---

## B. File Structure (MANDATORY)

Create or verify:

- [ ] `src/starkernel/vm/vm_core.c`
- [ ] `src/starkernel/vm/vm_bootstrap.c`
- [ ] `src/starkernel/vm/vm_runtime.c`

---

## C. Layer Responsibilities

### vm_core.c
- [ ] Execution engine only
- [ ] Direct-threaded XT dispatch
- [ ] Stack operations
- [ ] NO allocation
- [ ] NO HAL calls
- [ ] NO bootstrap logic
- [ ] NO logging
- [ ] NO XT ownership decisions

### vm_bootstrap.c
- [ ] Create VM instance
- [ ] Allocate VM arena
- [ ] Allocate dictionary
- [ ] Allocate TIB / >IN / SPAN
- [ ] Create STARFORTH vocabulary directly (C calls only)
- [ ] Register all primitives
- [ ] Assign XT ownership metadata
- [ ] Declare executable XTs
- [ ] Emit parity snapshot
- [ ] Enable interpreter ONLY after success

### vm_runtime.c
- [ ] TIME / TICKS / HB words
- [ ] Heartbeat integration
- [ ] L7/L8 hooks only
- [ ] NO dictionary mutation

---

## D. Interpreter Guard

- [ ] `vm->interpreter_enabled = false` at VM creation
- [ ] Any call to `vm_interpret*()` before enable → PANIC
- [ ] No token parsing during bootstrap
- [ ] No VOCABULARY execution via interpreter
- [ ] No DEFINITIONS execution via interpreter
- [ ] Interpreter enabled only after parity snapshot

---

## E. XT Validity Rules

- [ ] Remove address-range XT checks
- [ ] Implement ownership-based XT validation
- [ ] Acceptable XT only if registered by vm_bootstrap
- [ ] vm_core queries validity
- [ ] vm_bootstrap owns truth

---

## F. Dictionary Canary Instrumentation

Add guards for:
- [ ] Dictionary header region
- [ ] Word headers
- [ ] Parameter fields
- [ ] XT storage

Checks:
- [ ] Canary before registration
- [ ] Canary after each registration block
- [ ] Panic immediately on corruption

---

## G. Primitive Registration Tracing

For EACH word registered:
- [ ] Word name
- [ ] XT pointer
- [ ] Dictionary offset
- [ ] Ownership tag
- [ ] Executable flag

STOP immediately on:
- [ ] Invalid XT
- [ ] Canary violation
- [ ] Unexpected interpreter call

---

## H. Phase A Success Criteria

ALL must be true:

- [ ] No IFETCH faults
- [ ] No interpreter usage
- [ ] Parity snapshot emitted
- [ ] Dictionary hash matches hosted build
- [ ] Heartbeat continues running
- [ ] VM does not touch forbidden services

---

## I. Required Serial Output



PARITY:M7.1a
word_count=...
here=0x...
latest_id=...
hash=0x...
PARITY:OK


---

## J. Explicitly Out of Scope

DO NOT touch:
- [ ] REPL
- [ ] INIT capsules
- [ ] Colon definitions
- [ ] Literals
- [ ] Framebuffer
- [ ] Scheduler
- [ ] Multi-VM
- [ ] Performance tuning

---

---

## K. Boot Path Requirements (MANDATORY)

M7 is NOT complete until the same kernel image successfully boots through **all three boot paths** below without behavior divergence.

These are not optional, and they define the boundary between M7 and M8.

---

### K.1 Required Boot Paths (IN ORDER)

Codex MUST validate the kernel VM through the following sequence:

1. **QEMU (direct kernel boot)**
  - [ ] Existing `make -f Makefile.starkernel qemu`
  - [ ] Used for rapid iteration and instrumentation
  - [ ] Canonical for early parity debugging
  - [ ] Must reach Phase-A parity snapshot

2. **QEMU via ISO**
  - [ ] New `make iso` target REQUIRED
  - [ ] ISO must contain the same kernel binary
  - [ ] Boot path must go through firmware → ISO → kernel
  - [ ] No special QEMU-only shortcuts allowed
  - [ ] Serial output and parity results MUST match direct QEMU boot

3. **Physical Boot (ISO → Thumb Drive → Beelink)**
  - [ ] ISO written to USB thumb drive
  - [ ] Booted on Beelink hardware
  - [ ] No debugger, no copy/paste, serial/log-only visibility
  - [ ] Behavior must match both QEMU paths
  - [ ] This path is the FINAL validation of M7

---

### K.2 Behavioral Invariants Across Boot Paths

For all three boot paths:

- [ ] Same kernel binary
- [ ] Same VM arena layout
- [ ] Same primitive registration order
- [ ] Same XT ownership rules
- [ ] Same parity snapshot values
- [ ] No conditional logic based on boot medium
- [ ] No “QEMU-only” code paths
- [ ] No “hardware-only” code paths

If behavior differs:
- STOP
- Diagnose
- Fix at the lowest common layer (never patch per-boot-path)

---

### K.3 Logging & Observability Rules

Because physical boot has limited visibility:

- [ ] Serial logging is REQUIRED
- [ ] Parity snapshot MUST be emitted over serial
- [ ] No reliance on interactive REPL or framebuffer output
- [ ] Logs must be human-transcribable if necessary
- [ ] Any debug-only logging must be removable via a single flag

Codex MUST assume:
> Physical boot debugging is slow, painful, and one-time — design accordingly.

---

### K.4 Scope Boundary

- M7 ENDS when:
  - [ ] Phase-A parity snapshot succeeds
  - [ ] POST consumer is callable (even if disabled)
  - [ ] All three boot paths work identically

- M8 BEGINS when:
  - [ ] INIT/POST sequencing is enabled
  - [ ] ISO boot becomes the default dev path
  - [ ] REPL work begins

---

### K.5 Forbidden Shortcuts

Codex MUST NOT:

- [ ] Skip ISO boot to “save time”
- [ ] Defer physical boot validation
- [ ] Introduce boot-path conditionals
- [ ] Modify kernel behavior to accommodate firmware quirks
- [ ] Treat QEMU success as sufficient

Boot correctness is architectural, not incremental.

---

## L. Documentation Rule

- [ ] Update ONLY M7.md
- [ ] Do NOT create new milestone files
- [ ] Append findings, do not fork documentation
