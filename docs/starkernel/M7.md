# M7: VM Integration — Hardened Implementation Plan

**Status:** Planning
**Last Updated:** 2025-12-25
**Author:** Claude (reviewed by Captain Bob)

---

## Overview

M7 brings the StarForth VM into the kernel. Success is measured by **parity** — the kernel VM must produce structurally identical results to hosted StarForth.

This plan incorporates fixes for 7 identified landmines that would otherwise waste debugging time.

---

## Sub-Milestones

### M7.1a: Bootstrap Parity-Ready (No Output)

**Goal:** VM initializes, dictionary populated, bootstrap verifiable via silent self-check.

**Exit Criteria:**
- Bootstrap returns `BOOTSTRAP_OK`
- Summary packet matches hosted:
  - `word_count` (number of dictionary entries)
  - `here_offset` (dictionary usage in bytes)
  - `latest_word_id` (stable ID of most recent word)
  - `header_hash64` (canonical dictionary hash)

**NO printing required.** If sanity check desired: execute `1 2 +` and assert `vm->data_stack[vm->dsp] == 3` from kernel code.

---

### M7.1b: POST Parity

**Goal:** Full test suite runs with identical results to hosted StarForth.

**Exit Criteria:**
- `tests_total/passed/failed/skipped/errors` match hosted exactly
- Canonical dictionary hash matches hosted
- Rolling window hash matches (if inputs deterministic)

---

## Non-Negotiables (LLM Instructions)

**Claude / Codex / All LLMs:**

1. **NO global malloc→kmalloc sweep.** Allocation goes through `vm->host.alloc/free` hooks only.

2. **VM arena MUST be PMM-backed contiguous pages**, not a single giant heap allocation.

3. **Dictionary hashing MUST be canonicalized** — no raw pointers, no padding, no runtime fields.

4. **Tests run under deterministic time** — fake clock for parity mode (both hosted and kernel).

5. **NO new subsystems** — no threads, no scheduler, no devices. Single-thread, polled serial only.

6. **Stubs return SUCCESS, not failure** — pthread_create does nothing but returns 0.

7. **Test modules gated by `STARFORTH_ENABLE_TESTS`** — not in normal kernel image.

---

## Normative Rules (Frozen)

### Rule 1: word_id Assignment (Monotonic)

`word_id` is assigned as a strictly monotonic creation index:

```
word_id = creation_index, starting at 0
```

**Independent of:**
- Allocation address
- Build order variance
- Hash table iteration order
- Host vs kernel environment

**Invariant:** If hosted assigns word_id=42 to `DUP`, kernel assigns word_id=42 to `DUP`.

### Rule 2: Colon Body Hashing (No Absolute Addresses)

When hashing compiled (colon) word bodies:

- Hash the `word_id` of each called word, NOT the XT address
- Ignore literal cell addresses (hash the literal value only)
- Normalize control flow markers to relative offsets

**Rule:** If two definitions behave identically, their canonical hash MUST match regardless of memory placement.

### Rule 3: Dictionary Traversal Order (Creation Order)

Canonical dictionary traversal is **creation order** (oldest → newest):

- Independent of `link` pointer direction
- Independent of memory layout
- Deterministic across all builds

**Implementation:** Build array from `latest→link` chain, then iterate in reverse.

---

## Architecture

### VM Arena Allocation (Landmine #1 Fix)

**Problem:** `kmalloc(5MB)` fragments heap, causes subtle allocator bugs.

**Solution:** Allocate VM arena from PMM as contiguous pages.

```c
// src/starkernel/vm_kernel.c

#define VM_ARENA_PAGES ((VM_MEMORY_SIZE + PMM_PAGE_SIZE - 1) / PMM_PAGE_SIZE)

int sk_vm_arena_alloc(VM *vm) {
    // Allocate contiguous physical pages
    uint64_t paddr = pmm_alloc_contiguous(VM_ARENA_PAGES);
    if (paddr == 0) {
        return -1;  // Out of memory
    }

    // Map pages RW, NX into virtual address space
    uint64_t vaddr = VMM_VM_ARENA_BASE;  // Define a reserved VA range
    for (size_t i = 0; i < VM_ARENA_PAGES; i++) {
        vmm_map_page(vaddr + i * PMM_PAGE_SIZE,
                     paddr + i * PMM_PAGE_SIZE,
                     VMM_FLAG_WRITABLE | VMM_FLAG_NX);
    }

    vm->memory = (uint8_t *)(uintptr_t)vaddr;
    return 0;
}
```

### Host Allocator Hooks (Landmine #2 Fix)

**Problem:** Global malloc replacement is invasive and error-prone.

**Solution:** Host allocator function pointers inside VM structure.

```c
// include/starkernel/vm_host.h

typedef void* (*sk_alloc_fn)(size_t size, size_t align);
typedef void  (*sk_free_fn)(void *ptr);
typedef uint64_t (*sk_time_fn)(void);

typedef struct {
    sk_alloc_fn alloc;
    sk_free_fn  free;
    sk_time_fn  monotonic_ns;
} VMHostServices;

// In VM struct (or passed to init):
// VMHostServices host;
```

**Hosted:**
```c
static void* hosted_alloc(size_t size, size_t align) {
    (void)align;
    return malloc(size);
}
static void hosted_free(void *ptr) { free(ptr); }
static uint64_t hosted_time(void) { return sf_monotonic_ns(); }

VMHostServices hosted_services = {
    .alloc = hosted_alloc,
    .free = hosted_free,
    .monotonic_ns = hosted_time
};
```

**Kernel:**
```c
static void* kernel_alloc(size_t size, size_t align) {
    return kmalloc_aligned(size, align);
}
static void kernel_free(void *ptr) { kfree(ptr); }
static uint64_t kernel_time(void) {
    // For parity mode, return deterministic value
#if PARITY_MODE
    static uint64_t fake_ns = 0;
    return fake_ns += 1000;  // 1μs per call
#else
    return arch_read_timestamp() * timer_ns_per_tick();
#endif
}

VMHostServices kernel_services = {
    .alloc = kernel_alloc,
    .free = kernel_free,
    .monotonic_ns = kernel_time
};
```

### Canonical Dictionary Hash (Landmine #4 Fix)

**Problem:** Raw memory hash includes pointers, padding, runtime fields — will never match.

**Solution:** Hash only structural fields in traversal order.

**DictEntry fields to hash:**
| Field | Include? | Reason |
|-------|----------|--------|
| `link` | NO | Raw pointer |
| `func` | NO | Function pointer |
| `flags` | YES | Structural attribute |
| `name_len` | YES | Structural |
| `name[]` | YES | Word identity |
| `execution_heat` | NO | Runtime state |
| `acl_default` | YES | Structural attribute |
| `word_id` | YES | Stable identifier |
| `physics` | NO | Runtime metadata |
| `transition_metrics` | NO | Pointer |

**For colon definitions, also hash:**
- Body length (bytes from DF to HERE at definition time)
- Body content as relative offsets (word_id of each called word)

```c
// src/starkernel/parity.c

static uint64_t fnv1a_64(const uint8_t *data, size_t len, uint64_t hash) {
    for (size_t i = 0; i < len; i++) {
        hash ^= data[i];
        hash *= 0x100000001B3ULL;
    }
    return hash;
}

uint64_t sk_dict_canonical_hash(VM *vm) {
    uint64_t hash = 0xCBF29CE484222325ULL;  // FNV offset basis

    // Traverse dictionary in reverse order (oldest to newest)
    // Build temporary array of entries, then iterate
    DictEntry *entries[DICTIONARY_SIZE];
    uint32_t count = 0;

    for (DictEntry *e = vm->latest; e != NULL; e = e->link) {
        if (count < DICTIONARY_SIZE) {
            entries[count++] = e;
        }
    }

    // Hash in reverse (oldest first for determinism)
    for (int i = (int)count - 1; i >= 0; i--) {
        DictEntry *e = entries[i];

        // Hash structural fields only
        hash = fnv1a_64(&e->flags, 1, hash);
        hash = fnv1a_64(&e->name_len, 1, hash);
        hash = fnv1a_64((uint8_t *)e->name, e->name_len, hash);
        hash = fnv1a_64(&e->acl_default, 1, hash);
        hash = fnv1a_64((uint8_t *)&e->word_id, sizeof(e->word_id), hash);

        // For colon definitions, hash body as word_id sequence
        if (e->flags & WORD_COMPILED) {
            cell_t *df = vm_dictionary_get_data_field(e);
            if (df) {
                vaddr_t body_addr = (vaddr_t)(uint64_t)(*df);
                // Hash body word IDs (implementation detail)
                // ... traverse threaded code, hash each word_id ...
            }
        }
    }

    return hash;
}
```

### Deterministic Time for Parity (Landmine #6 Fix)

**Problem:** Real time differs between hosted and kernel runs.

**Solution:** Fake clock for parity mode.

```c
// Build flag: -DPARITY_MODE=1

#if PARITY_MODE
// Deterministic time: increments by 1000ns per call
static uint64_t parity_fake_ns = 0;
uint64_t sf_monotonic_ns(void) {
    return parity_fake_ns += 1000;
}
#endif
```

**Hosted parity baseline:**
```bash
# Build hosted with parity mode
make PARITY_MODE=1 standard
./build/amd64/standard/starforth --run-tests --parity
```

**Kernel parity:**
```bash
# Build kernel with parity mode
make -f Makefile.starkernel PARITY_MODE=1 kernel
# Run in QEMU and compare output
```

### Stub Success, Not Failure (Landmine #5 Fix)

**Problem:** pthread_create returning -1 may cause abort.

**Solution:** Stubs succeed silently, do nothing.

```c
// src/starkernel/vm_host.c

#ifdef __STARKERNEL__

// Mutex: no-op but returns success
int sf_mutex_init(sf_mutex_t *m) { (void)m; return 0; }
int sf_mutex_lock(sf_mutex_t *m) { (void)m; return 0; }
int sf_mutex_unlock(sf_mutex_t *m) { (void)m; return 0; }
void sf_mutex_destroy(sf_mutex_t *m) { (void)m; }

// Thread: compile out entirely
// In vm.c, wrap thread creation:
#if HEARTBEAT_HAS_THREADS
// ... thread code ...
#endif
// In kernel build: HEARTBEAT_HAS_THREADS=0

#endif
```

### Gated Test Modules (Landmine #7 Fix)

**Problem:** Importing all test code bloats kernel.

**Solution:** Gate behind `STARFORTH_ENABLE_TESTS`.

```makefile
# Makefile.starkernel

# M7.1a: Core VM only
VM_CORE_SOURCES = \
    src/starkernel/vm_kernel.c \
    src/starkernel/vm_host.c \
    src/starkernel/parity.c \
    src/vm.c \
    src/word_registry.c \
    src/word_source/*.c

# M7.1b: Add tests only when needed
ifdef STARFORTH_ENABLE_TESTS
VM_SOURCES = $(VM_CORE_SOURCES) \
    src/test_runner/test_runner.c \
    src/test_runner/modules/*.c
KERNEL_CFLAGS += -DSTARFORTH_ENABLE_TESTS=1
else
VM_SOURCES = $(VM_CORE_SOURCES)
endif
```

---

## Parity Packet Structure

```c
// include/starkernel/parity.h

typedef struct {
    // M7.1a fields (bootstrap)
    uint32_t word_count;           // Number of dictionary entries
    uint32_t here_offset;          // vm->here (bytes used)
    uint32_t latest_word_id;       // vm->latest->word_id
    uint64_t header_hash64;        // Canonical dictionary hash

    // M7.1b fields (POST)
    uint32_t tests_total;
    uint32_t tests_passed;
    uint32_t tests_failed;
    uint32_t tests_skipped;
    uint32_t tests_errors;

    // Optional (if rolling window is deterministic)
    uint64_t window_hash64;
} ParityPacket;

// Collection function
void sk_parity_collect(VM *vm, ParityPacket *out);

// Print as hex line (for serial comparison)
void sk_parity_print(const ParityPacket *pkt);
```

**Output format:**
```
PARITY:M7.1a word_count=245 here=0x1A2B3C latest_id=244 hash=0xDEADBEEF12345678
PARITY:M7.1b tests=936 pass=936 fail=0 skip=0 err=0
PARITY:MATCH or PARITY:MISMATCH
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `include/starkernel/vm_host.h` | Host services interface |
| `src/starkernel/vm_host.c` | Kernel host service implementations |
| `src/starkernel/vm_kernel.c` | Kernel VM initialization (PMM arena) |
| `include/starkernel/parity.h` | Parity packet structure |
| `src/starkernel/parity.c` | Canonical hash + parity collection |

## Files to Modify

| File | Changes |
|------|---------|
| `include/vm.h` | Add `VMHostServices *host` field |
| `src/vm.c` | Use `vm->host->alloc()` instead of `malloc()` |
| `src/word_registry.c` | Conditional compilation for kernel |
| `Makefile.starkernel` | Add VM sources, PARITY_MODE, STARFORTH_ENABLE_TESTS |
| `src/starkernel/kernel_main.c` | Call `sk_vm_init()`, collect parity |

---

## Implementation Order

### Week 1: M7.1a Bootstrap

**Day 1:** Create `vm_host.h` with allocator/time hooks
**Day 2:** Create `vm_kernel.c` with PMM-backed arena allocation
**Day 3:** Modify `vm.c` to use host hooks (guarded by `__STARKERNEL__`)
**Day 4:** Wire up dictionary registration, verify compilation
**Day 5:** Implement parity collection, compare hosted vs kernel summary

### Week 2: M7.1b POST

**Day 1:** Port test runner with `STARFORTH_ENABLE_TESTS` gate
**Day 2:** Fix any word modules that fail to compile for kernel
**Day 3:** Implement deterministic time mode for parity
**Day 4:** Run full POST in QEMU, compare to hosted baseline
**Day 5:** Debug any parity mismatches

---

## Validation Commands

**Hosted baseline:**
```bash
make clean
make PARITY_MODE=1 standard
./build/amd64/standard/starforth --run-tests --parity > /tmp/hosted_parity.txt
```

**Kernel under test:**
```bash
make -f Makefile.starkernel clean-kernel
make -f Makefile.starkernel PARITY_MODE=1 STARFORTH_ENABLE_TESTS=1 kernel
# Capture QEMU output
timeout 60 make -f Makefile.starkernel qemu 2>&1 | tee /tmp/kernel_out.txt
grep "^PARITY:" /tmp/kernel_out.txt > /tmp/kernel_parity.txt
```

**Compare:**
```bash
diff /tmp/hosted_parity.txt /tmp/kernel_parity.txt && echo "PARITY OK" || echo "PARITY MISMATCH"
```

---

## Risk Mitigations

| Risk | Mitigation |
|------|------------|
| Heap fragmentation | VM arena is PMM-backed, not heap |
| Pointer-in-hash | Canonical hash excludes all pointers |
| Time divergence | PARITY_MODE uses fake deterministic clock |
| Thread stubs break caller | Stubs return success, do nothing |
| Kernel bloat from tests | Tests gated by STARFORTH_ENABLE_TESTS |
| Allocator semantics differ | All allocation via host hooks |

---

## Success Criteria

**M7.1a PASS:**
```
PARITY:M7.1a word_count=245 here=0x1A2B3C latest_id=244 hash=0xDEADBEEF12345678
(matches hosted exactly)
```

**M7.1b PASS:**
```
PARITY:M7.1b tests=936 pass=936 fail=0 skip=0 err=0
PARITY:MATCH
```

---

*This plan incorporates fixes for all 7 identified landmines. No work proceeds until Captain Bob approves.*
